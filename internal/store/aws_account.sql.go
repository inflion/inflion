// Code generated by sqlc. DO NOT EDIT.
// source: aws_account.sql

package store

import (
	"context"
)

const allAwsAccount = `-- name: AllAwsAccount :many
SELECT account_id, role_name, external_id, project_id
FROM aws_account
`

type AllAwsAccountRow struct {
	AccountID  string
	RoleName   string
	ExternalID string
	ProjectID  int64
}

func (q *Queries) AllAwsAccount(ctx context.Context) ([]AllAwsAccountRow, error) {
	rows, err := q.query(ctx, q.allAwsAccountStmt, allAwsAccount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllAwsAccountRow
	for rows.Next() {
		var i AllAwsAccountRow
		if err := rows.Scan(
			&i.AccountID,
			&i.RoleName,
			&i.ExternalID,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAwsAccount = `-- name: GetAwsAccount :one
SELECT account_id, role_name, external_id, project_id
FROM aws_account
WHERE
    project_id = $1
LIMIT 1
`

type GetAwsAccountRow struct {
	AccountID  string
	RoleName   string
	ExternalID string
	ProjectID  int64
}

func (q *Queries) GetAwsAccount(ctx context.Context, projectID int64) (GetAwsAccountRow, error) {
	row := q.queryRow(ctx, q.getAwsAccountStmt, getAwsAccount, projectID)
	var i GetAwsAccountRow
	err := row.Scan(
		&i.AccountID,
		&i.RoleName,
		&i.ExternalID,
		&i.ProjectID,
	)
	return i, err
}
